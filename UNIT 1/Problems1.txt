LeetCode 28:
Implement strStr()
Problem: Given two strings haystack and needle, return the index of the first occurrence of needle in haystack.
Solution:
Naive method:
int strStr(string haystack, string needle) {
    int n = haystack.size(), m = needle.size();
    if (m == 0) return 0;
    for (int i = 0; i <= n-m; i++) {
        int j = 0;
        while (j < m && haystack[i+j] == needle[j]) j++;
        if (j == m) return i;
    }
    return -1;
}


LeetCode 187:
Repeated DNA Sequences
Find repeated DNA sequences (substring length = 10).
Solution:
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        unordered_set<string> seen, repeated;
        for(int i=0; i+9<s.size(); i++){
            string sub = s.substr(i, 10);
            if(seen.count(sub)) repeated.insert(sub);
            else seen.insert(sub);
        }
        return vector<string>(repeated.begin(), repeated.end());
    }
};


LeetCode 416: 
Partition Equal Subset Sum
Check if array can be partitioned into 2 subsets with equal sum.
This is exactly 0/1 Knapsack with target = totalSum/2.
Solution:
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % 2) return false;
    int target = sum / 2;
    vector<bool> dp(target+1, false);
    dp[0] = true;

    for (int num : nums) {
        for (int j = target; j >= num; j--) {
            dp[j] = dp[j] || dp[j-num];
        }
    }
    return dp[target];
}


LeetCode 943:
Find the Shortest Superstring
Equivalent to TSP on strings (DP with bitmasking).
Solution:
class Solution {
public:
    int n;
    vector<vector<int>> dirs{{1,0},{-1,0},{0,1},{0,-1}};
    
    void dfs(vector<vector<int>>& grid, int i, int j, queue<pair<int,int>>& q) {
        if(i<0 || j<0 || i>=n || j>=n || grid[i][j] != 1) return;
        grid[i][j] = 2; // mark visited (island 1)
        q.push({i,j});
        for(auto &d: dirs) dfs(grid, i+d[0], j+d[1], q);
    }
    
    int shortestBridge(vector<vector<int>>& grid) {
        n = grid.size();
        queue<pair<int,int>> q;
        bool found = false;
        
        // Step 1: Find first island and mark it
        for(int i=0; i<n && !found; i++){
            for(int j=0; j<n && !found; j++){
                if(grid[i][j] == 1){
                    dfs(grid, i, j, q);
                    found = true;
                }
            }
        }
        
        // Step 2: BFS to reach second island
        int steps = 0;
        while(!q.empty()){
            int sz = q.size();
            while(sz--){
                auto [x,y] = q.front(); q.pop();
                for(auto &d: dirs){
                    int nx=x+d[0], ny=y+d[1];
                    if(nx<0 || ny<0 || nx>=n || ny>=n) continue;
                    if(grid[nx][ny] == 1) return steps; // reached second island



LeetCode 509:
Fibonacci Number
Compare recursive O(2^n) vs DP O(n).
Solution:
int fib(int n) {
    if (n <= 1) return n;
    vector<int> dp(n+1);
    dp[0] = 0, dp[1] = 1;
    for (int i = 2; i <= n; i++) dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
}


LeetCode 912: 
Sort an Array
use Merge Sort/Quick Sort (O(n log n)), Selection Sort (O(nÂ²)).
Solution:
class Solution {
public:
    void merge(vector<int>& nums, int l, int m, int r) {
        vector<int> left(nums.begin() + l, nums.begin() + m + 1);
        vector<int> right(nums.begin() + m + 1, nums.begin() + r + 1);

        int i = 0, j = 0, k = l;
        while (i < left.size() && j < right.size()) {
            if (left[i] <= right[j]) nums[k++] = left[i++];
            else nums[k++] = right[j++];
        }
        while (i < left.size()) nums[k++] = left[i++];
        while (j < right.size()) nums[k++] = right[j++];
    }

    void mergeSort(vector<int>& nums, int l, int r) {
        if (l >= r) return;
        int m = (l + r) / 2;
        mergeSort(nums, l, m);
        mergeSort(nums, m+1, r);
        merge(nums, l, m, r);
    }

    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size()-1);
        return nums;
    }
};

leetcode 70:
Climbing array
Solution:
class Solution {
public:
    int climbStairs(int n) {
        if(n<=2) return n;
        int a=1, b=2, c;
        for(int i=3; i<=n; i++) {
            c = a+b;
            a=b; b=c;
        }
        return b;
    }
};


leetcode 78:
Backtracking / Power Set Generation
Solution:
class Solution {
public:
    void backtrack(vector<int>& nums, int start, vector<int>& curr, vector<vector<int>>& res) {
        res.push_back(curr);
        for(int i=start; i<nums.size(); i++) {
            curr.push_back(nums[i]);
            backtrack(nums, i+1, curr, res);
            curr.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> curr;
        backtrack(nums, 0, curr, res);
        return res;
    }
};


leetcode 704:
Conquer search
Solution:
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l=0, r=nums.size()-1;
        while(l<=r) {
            int mid=(l+r)/2;
            if(nums[mid]==target) return mid;
            else if(nums[mid]<target) l=mid+1;
            else r=mid-1;
        }
        return -1;
    }
};


leetcode 46:
Permutations
Solution:
class Solution {
public:
    void backtrack(vector<int>& nums, vector<vector<int>>& res, int start) {
        if(start == nums.size()) {
            res.push_back(nums);
            return;
        }
        for(int i=start; i<nums.size(); i++) {
            swap(nums[start], nums[i]);
            backtrack(nums, res, start+1);
            swap(nums[start], nums[i]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        backtrack(nums, res, 0);
        return res;
    }
};


