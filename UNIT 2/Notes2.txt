Brute Force Algorithm:

Definition:
    A Brute Force algorithm is a straightforward approach that tries all possible 
    solutions to solve a problem. It does not use shortcuts or optimizations—it relies
    purely on computational power and exhaustive search.


Characteristics:

    1.Simple to understand and implement.
    2.Guaranteed to find a solution if one exists.
    3.Inefficient for large inputs—time complexity is usually high.
    4.Often used as a baseline to compare with optimized algorithms. 

Pros:
    Easy to implement.
    Always finds the correct solution.
    Good for small problem sizes or as a learning tool.

Cons:
    Very slow for large input sizes.
    High time and sometimes space complexity.
    Not practical for real-world large datasets.      

Selection Sort:

Definition:
    Selection Sort is a simple comparison-based sorting algorithm.
    It repeatedly selects the minimum (or maximum) element from the unsorted portion of the array and places it in the correct position in the sorted portion.
    It works in-place, meaning it doesn’t need extra memory.   

Algorithm:
    for i = 0 to n-1
    min_index = i
    for j = i+1 to n-1
        if arr[j] < arr[min_index]
            min_index = j
    swap arr[i] and arr[min_index]

Time Complexity:
    Best case: O(n²) – comparisons always made
    Worst case: O(n²) – same as above
    Average case: O(n²)

Space Complexity:
    O(1) (in-place sorting)

Stability: 
    Not stable (can change relative order of equal elements)   

Pros:
    Simple and easy to implement.
    Works in-place (no extra memory needed).

Cons:
    Very slow for large arrays (inefficient).
Not stable by default.     
     
String Matching:

Definition:
    String Matching (or Pattern Matching) is the process of finding occurrences of a 
    substring (pattern) within a larger string (text).

    Text (T): The main string in which we search.
    Pattern (P): The substring we are looking for. 
    
Naive (Brute Force) Approach:
    The simplest method is to slide the pattern over the text and compare characters
    one by one.

Steps:
    1.Start at the beginning of the text.
    2.Compare the pattern with the current substring of the text.
    3.If it matches, record the position.
    4.Move one position forward and repeat until the end of the text.    

Example

Text: "ABABAC"
Pattern: "ABA"

Start Index	Comparison	Match?
0	"ABA" vs "ABA"	✅ Yes, match at index 0
1	"BAB" vs "ABA"	❌ No
2	"ABA" vs "ABA"	✅ Yes, match at index 2
3	"BAC" vs "ABA"	❌ No

Result: Matches at index 0 and 2.

Pseudocode:
    for i = 0 to n - m
    j = 0
    while j < m and text[i+j] == pattern[j]
        j = j + 1
    if j == m
        print "Pattern found at index", i

Time Complexity:
    Worst case: O(n × m) – all positions are checked
    Best case: O(n) – when pattern length is 1 or mismatches early

Space Complexity:
    O(1) – no extra memory needed

Applications:
    1.Text editors (Ctrl+F search).
    2.DNA sequence analysis.
    3.Plagiarism detection.
    4.Spam filtering.
